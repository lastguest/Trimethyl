<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Geo'>/**
</span> * @class  	Geo
 * @author  Flavio De Stefano &lt;flavio.destefano@caffeinalab.com&gt;
 * Provide useful method for geolocation events
 *
 */

<span id='Geo-property-config'>/**
</span> * * **accuracy**: Accuracy of Geo. Must be one of `&quot;ACCURACY_HIGH&quot;`, `&quot;ACCURACY_LOW&quot;`
 * * **useGoogleForGeocode**: Tell to use Google Services instead of Titanium geocoding services.
 * @type {Object}
 */
var config = _.extend({
	accuracy: &quot;ACCURACY_HIGH&quot;,
	useGoogleForGeocode: true
}, Alloy.CFG.geo);
exports.config = config;


function checkForServices() {
	return Ti.Geolocation.locationServicesEnabled;
}

<span id='Geo-method-enableServicesAlert'>/**
</span> * Alert the user that Location is off
 */
function enableServicesAlert(){
	if (OS_IOS) {
		require(&#39;T/util&#39;).alert(L(&#39;geo_error_title&#39;), L(&#39;geo_error_msg&#39;));
	} else {
		require(&#39;T/util&#39;).simpleAlert(L(&#39;geo_error_title&#39;));
	}
}
exports.enableServicesAlert = enableServicesAlert;


<span id='Geo-method-localize'>/**
</span> * Get the current GPS coordinates of user using `Ti.Geolocation.getCurrentPosition`
 *
 * If there&#39;s an error, the callback is invoked with `{ error: true, success: false }`,
 * so pay attention to the returned value
 *
 * A `geo.start` event is fired at start
 *
 * A `geo.end` event is fired on end
 *
 * @param  {Function} cb Callback (success or error)
 */
function localize(cb) {
	if (!checkForServices()) {
		return cb({ error: true, servicesDisabled: true });
	}

	Ti.App.fireEvent(&#39;geo.start&#39;);
	Ti.Geolocation.purpose = L(&#39;geo_purpose&#39;);
	Ti.Geolocation.accuracy = Ti.Geolocation[config.accuracy];

	Ti.Geolocation.getCurrentPosition(function(e){
		Ti.App.fireEvent(&#39;geo.end&#39;);

		if (!e.success || !e.coords) {
			cb({ error: true });
		} else {
			cb(e);
		}

	});
}
exports.localize = localize;


<span id='Geo-method-startNavigator'>/**
</span> * Open Apple Maps on iOS, Google Maps on Android and route from user location to defined location
 *
 * @param  {Number} lat  	Desination latitude
 * @param  {Number} lng  	Destination longitude
 * @param  {String} [mode] GPS mode used (walking,driving)
 */
function startNavigator(lat, lng, mode) {
	localize(function(e) {
		if (!e.success) {
			require(&#39;T/util&#39;).alertError(L(&#39;geo_unabletonavigate&#39;));
			return;
		}

		var D = OS_IOS ? &quot;http://maps.apple.com/&quot; : &quot;https://maps.google.com/maps/&quot;;
		Ti.Platform.openURL(D + require(&#39;T/util&#39;).buildQuery({
			directionsmode: mode || &#39;walking&#39;,
			saddr: e.coords.latitude + &quot;,&quot; + e.coords.longitude,
			daddr: lat + &quot;,&quot; + lng
		}));
	});
}
exports.startNavigator = startNavigator;


<span id='Geo-method-geocode'>/**
</span> * Return the coordinates of an address
 *
 * If some errors occurs, the callback in invoked
 * anyway with `{ error: true, success: false }`
 *
 * @param  {String}   address 	The address to geocode
 * @param  {Function} cb      	The callback
 */
function geocode(address, cb) {
	if (config.useGoogleForGeocode) {

		require(&#39;T/net&#39;).send({
			url: &#39;http://maps.googleapis.com/maps/api/geocode/json&#39;,
			cache: false,
			data: {
				address: address,
				sensor: &#39;false&#39;
			},
			mime: &#39;json&#39;,
			success: function(res){

				if (res.status!=&#39;OK&#39; || !res.results.length) {
					cb({ error: true });
				} else {
					cb({
						success: true,
						latitude: res.results[0].geometry.location.lat,
						longitude: res.results[0].geometry.location.lng
					});
				}

			},
			error: function(err){
				Ti.API.error(&quot;Geo: &quot;+err);
				cb({ error: true });
			}
		});

	} else {

		Ti.Geolocation.forwardGeocoder(address, function(res){

			if (!res.success) {
				cb({ error: true });
			} else {
				cb({
					success: true,
					latitude: res.latitude,
					longitude: res.longitude
				});
			}

		});
	}
}
exports.geocode = geocode;


<span id='Geo-method-reverseGeocode'>/**
</span> * Return the address with the specified coordinates
 *
 * If some errors occurs, the callback in invoked
 * anyway with `{ error: true, success: false }`
 *
 * @param  {Number}   lat 	The latitude of the address
 * @param  {Number}   lng 	The longitude of the address
 * @param  {Function} cb  The callback
 */
function reverseGeocode(lat, lng, cb) {
	if (!lat || !lng) {
		return cb({ error: true });
	}

	if (config.useGoogleForGeocode) {

		require(&#39;T/net&#39;).send({
			url: &#39;http://maps.googleapis.com/maps/api/geocode/json&#39;,
			noCache: true,
			data: {
				latlng: lat+&#39;,&#39;+lng,
				sensor: &#39;false&#39;
			},
			mime: &#39;json&#39;,
			success: function(res){

				if (res.status!=&#39;OK&#39; || !res.results.length) {
					cb({ error: true });
				} else {
					cb({
						success: true,
						address: res.results[0].formatted_address,
						results: res.results
					});
				}

			},
			error: function(err){
				Ti.API.error(&quot;Geo: &quot;+err);
				cb({ error: true });
			}
		});

	} else {

		Ti.Geolocation.reverseGeocoder(lat, lng, function(res){

			if (!res.success || !res.places || !res.places.length) {
				cb({ error: true });
			} else {
				cb({
					success: true,
					address: res.places[0].address,
					results: res.places
				});
			}

		});
	}
}
exports.reverseGeocode = reverseGeocode;
</pre>
</body>
</html>
